## 프로세스란?
* 실행중인 프로그램은 프로세스라고 함
    - 프로세스 : 메모리에 올려져서, 실행 중인 프로그램
    - 코드 이미지(바이너리): 실행 파일
    - 프로세스라는 용어는 작업, task, job 이라는 용어와 혼용

* 응용프로그램 != 프로세스
    - 응용 프로그램은 여러 개의 프로세스로 이루어질 수 있음
    - 하나의 응용 프로그램은 여러 개의 프로세스(프로그램)가 상호작용을 하면서 실행할 수도 있음

 ## 스케쥴러와 프로세스
 > 누가 프로세스 실행을 관리하는가? 스케쥴러!

 ## 스케쥴링 알고리즘
 > 어느 순서대로 프로세스를 실행시킬까?

 * 시분할 시스템 예 : 프로세스 응답 시간을 가능한 짧게
 * 멀티 프로그래밍 예 : CPU 활용도를 최대로 높여서, 프로세스를 빨리 실행


 ## FIFO 스케쥴러
 > 가정 : 프로세스가 파일I/O나 프린팅과같은 작업이 없다고 가정
* 가장 간단한 스케쥴러(배치 처리 시스템)
* FCFS(First come First Served) 스케쥴러


 ## 최단 작업 우선(SJF) 스케쥴러
 * SJF(Shortest Job First) 스케쥴러
    - 가장 프로세스 시간이 짧은 프로세스부터 실행하는 알고리즘

## 우선순위 기반 스케쥴러
* Priority-Based 스케쥴러
    - 정적 우선순위
        - 프로세스마다 우선순위를 미리 지정
    - 동적 우선순위
        - 스케쥴러가 상황에 따라 우선순위를 동적으로 변경

## Round Robin 스케쥴러 (Round Robin Queue)
* 시분할과 FIFO의 결합과 비슷한 개념
    - 프로세스가 끝나지 않아도 프로세스를 쪼개서 여러 프로세스를 순서대로 실행-중단-실행 방식으로 진행
    - Queue 형태로 프로세스가 실행완료될때까지 CPU에 반복적으로 작업을 들어가고 나와서 다시 Queue로 작업이 돌게 되므로 '빙빙 돈다'처럼 느껴져서 Round Robin

## 프로세스 상태와 스케쥴링
* 멀티프로그래밍과 Wait 상태
    - 프로그램 A가 파일 I/O등의 유휴작업에 들어가는 동안 다른 프로그램들을 돌려서 CPU를 효율적으로 사용한다
* 프로세스 상태
    - process start(new): 프로세스 생성 - 아주 짧은 특이한 시점
    - running state: 현재 CPU에서 실행 상태
    - ready state: CPU 에서 실행 가능 상태 (실행 대기 상태)
    - block state: 특정 이벤트 발생 대기 상태 (예: 프린팅이 다 되었다!) - 해당 프로세스의 wait 상태, 특정 이벤트가 발생하면 ready로 변경!
    - process exit: 프로세스 종료 - 프로세스에서 활용한 자원을 반납하고 종료하는 상태 
> runnig, block, ready가 실질적으로 중요하다
    
* Queue를 활용한 상태 경합의 해결
    - Ready State Queue, Running State Queue, Block State Queue 를 통해 각각 상태변경에 대한 작업을 선입선출 방식으로 경합의 우선순위를 해결
* 우선순위, 최단시간 스케쥴링 알고리즘 등을 쓸 경우 각각 알고리즘에 따라서 실행순서는 변경될 수 있다.
* 실제 OS의 프로세스 관리는 훨씬 복잡한 알고리즘을 통해 최적화 된다.

