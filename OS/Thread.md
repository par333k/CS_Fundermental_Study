## Thread (스레드)

* Light Weight Process 라고도 함
* 프로세스
    * 프로세스 간에는 각 프로세스의 데이터 접근이 불가 (IPC를 써야함)
* 스레드
    * 하나의 프로세스에 여러개의 스레드 생성이 가능
    * 스레드 들은 동시에 실행 가능
    * 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근이 가능

### 스레드는 각기 사용이 가능한 stack이 존재

* 스레드의 스택 포인터
    * 프로세스에서 스레드와 힙 메모리 영역 사이에 각 스레드를 위한 스레드 스택포인터 함수가 존재하는 메모리 영역 할당
    * 프로세스의 스택을 스레드별로 나누어 사용
    * 힙, BSS, DATA, CODE 영역은 함께 공유해서 사용한다

### Multi Thread (멀티 스레드)

* 소프트웨어 병행 작업 처리를 위해 멀티 스레드를 사용함

### 멀티 프로세싱과 스레드

* 멀티 테스킹 : CPU 하나로 프로세스 여러개를 아주 짧은 시간동안 프로세스 실행을 변경하면서 작업을 동시성있게 실행되는 것처럼 보이는 기법
* 멀티 프로세싱 : 하나의 프로세스와 여러 시피유, 혹은 여러 프로세스와 여러 시피유로 실행을 하는 병렬 실행으로 실행속도를 높이는 기법
    * 하나의 프로세스를 어러 CPU에 작업을 병렬 처리 하기 위한 기법 : 멀티 스레드 기법을 통해 작업을 진행.
    * 최근 CPU는 기본적으로 멀티 코어를 가지므로, Thread를 여러 개 만들어, 멀티 코어 활용도를 높임.

### 스레드의 장점
* 사용자에 대한 응답성 향상 
    * 한 프로세스 안에  A, B라는 스레드가 있다면, A는 특정 작업을 하면서  B는 사용자와의 커뮤니케이션만 하는데 작업을 할당한다거나 할 수 있다.
* 자원 공유 효율 (자원 효율)
    * IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요 없다
    * 프로세스 안에 있으므로, 프로세스의 데이터에 모두 접근 가능하다
* 작업이 분리되어 코드가 간결하다.
    * 사실 작성하기 나름이다 ㅋㅋ

### 스레드의 단점

* 스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받을 수 있다. 
* 스레드를 많이 생성하면, Context Switching이 많이 일어나 성능 저하 이슈가 생길 수 있다.
    * EX) 리눅스 OS 에서는 스레드를 프로세스처럼 다룬다.
        * 스레드를 많이 생성하면, 모든 스레드를 스케쥴링 해야하므로 Context Switching이 빈번할 수 밖에 없다 -> 복잡도 증가.
* 동기화 문제를 잘 처리해야 한다.

### 스레드와 프로세스의 비교

* 프로세스는 독립적, 스레드는 프로세스의 서브셋
* 프로세스는 각각 독립적인 자원을 가짐, 스레드는 프로세스 자원을 공유한다
* 프로세스는 자신만의 주소영역을 가짐, 스레드는 주소 영역을 공유한다
* 프로세스 간에는 IPC 기법으로 통신해야함, 스레드는 필요가 없다.

### PThread

* POSIX 스레드 (약어: PThread)
    * Thread 관련 표준 API

#### 스레드 개념 정리
- 프로세스와 달리 스레드간 자원 공유
- CPU 활용도 높이고 성능 개선 가능, 응답성 향상, 자원 공유 효율
- 하나의 스레드 문제가 프로세스 전반에 영향을 미칠 수 있음
- 여러 스레드 생성시 성능 저하 가능
- 스레드 동기화 문제 고려해야함


## 스레드 동기화 이슈

```
// 파이썬 코드 예제
import threading //  파이썬 스레드 관리 라이브러리

g_count = 0

def thread_main():
    num = 0
    global g_count  // 전역변수를 함수 내에서 사용하겠다는 의미
    for i in range(10000):
        g_count = g_count + 1

threads = []

for i in range(50):
    th = threading.Thread(target = thread_main)
    threads.append(th)

for th in threads:
    th.start()

for th in threads:
    th.join() // 다른 스레드가 다 끝날때까지 기다림 - 동기화 함수

print ('g_count =', g_count)
```

* 위 코드의 반복문 range를 늘릴 경우, 스레드에서 영향을 끼치는 전역변수의 실행에 대해 작업 도중 context switching 이 일어날 수 있다.
스케쥴러의 단위시간보다 긴 작업을 해야할 수 있기 때문이다. 이 때, 어느 시점에서 context switching이 일어나는지 확인할 수 없다.
해당 코드는 전역변수인 g_count를 읽고, 더하고, 다시 덮어서 저장하는 과정이다. 만일 스레드가 2개로 나뉘어 있을 때, 읽기-더하기-저장 과정에서
작업이 다 완료되지 않고 context switching 이 일어나게되면, 작업이 끝나지 않았던 스레드는 다음 스케쥴링때 메모리의 Register 값을 이전 값으로 초기화한다.
왜냐면 context switching이 일어나기 전에 g_count에 값을 쓰기 전에 실행이 중단되었기 때문이다. 이 경우, 원래는 덧셈이 두 번 완료되었어야 하는 것이
Register의 초기화로 인해 계산 결과에 오류가 발생한다.

### mutual exclusion

* 위 코드에서 실제로 문제가 발생하는 부분은 for 문에서 계산이 완전히 끝나기 전에 context switching 이 일어나기 때문이다. 따라서 이 부분을 연산이 끝나고 context switching이 일어나게 하면 문제를 해결할 수 있다.
* 해당 부분은 파이썬에서 제공하는 threading 라이브러리의 Lock() 함수를 이용한다. (언어별로 해법은 다를 수 있다)

```
import threading //  파이썬 스레드 관리 라이브러리

g_count = 0

def thread_main():
    num = 0
    global g_count  // 전역변수를 함수 내에서 사용하겠다는 의미
    lock.acquire() // 일종의 열쇠
    for i in range(10000):
        g_count = g_count + 1
    lock.release() // 잠금을 푼다, 릴리즈가 되기 전에는 다른 스레드가 임계함수(위의 반복문)을 호출하려고 해도 acquire()함수가 그것을 막는다.

threads = []

for i in range(50):
    th = threading.Thread(target = thread_main)
    threads.append(th)

for th in threads:
    th.start()

for th in threads:
    th.join() // 다른 스레드가 다 끝날때까지 기다림 - 동기화 함수

print ('g_count =', g_count)
```

### 동기화 이슈 

* 동기화: 작업들 사이에 실행 시기를 맞추는 것
* 여러 스레드가 동일한 자원(데이터) 접근시 동기화 이슈 발생
    * 동일 자원을 여러 스레드가 동시 수정시, 각 스레드 결과에 영향을 줌

### 동기화 이슈 해결 방안

* Mutual exclusion (상호 배제)
* 스레드는 프로세스 모든 데이터를 접근할 수 있으므로,
    * 여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access 필요
    * 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레그가 동시 접근하지 못하도록 막아라

#### Mutual exclusion (상호 배제) : Locking 메커니즘

* 임계 자원(critical resource) : 동시에 수정되어서는 안되는 자원
* 임계 영역(critical section)

```
lock.acquire()
// ---- 임계영역 -----
for i in range(100000):
    g_count += 1
// ------------------
lock.relase()
```

#### 동기화와 세마포어

- Mutex와 세마포어(Semaphore)

* Critical Section(임계 구역)에 대한 접근을 막기 위해 LOCKING 메커니즘이 필요
    * Mutex(binary semaphore) : 임계구역에 하나의 스레드만 들어갈 수 있음
    * Semaphore : 임계구역에 여러 스레드가 들어갈 수 있음, counter를 두어서 동시에 리소스에 접근할 수 있는 허용 가능한 스레드 수를 제어

- 세마포어 (Semaphore)

* P: 검사 (임계영역에 들어갈 때) - 파이썬 코드의 lock.acquire() 역할
    * S 값이 1 이상이면, 임계 영역 진입 후, S 값 1 차감 (S값이 0이면 대기)
* V: 증가 (임계영역에서 나올 때) - 파이썬 코드의 lock.release() 역할
    * S값을 1 더하고, 임계 영역을 나옴
* S: 세마포어 값 (초기 값만큼 여러 프로세스가 동시 임계 영역 접근 가능)

``` 
// pseudo code
P(S): wait (S) {  // wait 라는 작업을 할때 S가 1보다 커지면 1을 빼주고 코드를 종료, 이게 끝나면 임계영역 코드를 실행, 만약 인수로 받는 S가 1보다 큰 상태면 바로 임계영역 실행.
        while S <= 0 // 대기
        ;
    S--; // 다른 프로세스 접근 제한
}

V(S): signal(S) { // 임계영역이 끝나면 S를 1 증가시켜줌. 
        S++; // 다른 프로세스 접근 허용
} 

```
- 세마포어 (Semaphore) - 바쁜 대기

* wait() 는 S가 0이라면 임계영역에 들어가기 위해 반복문을 수행
    * 바쁜 대기, busy waiting (위 코드에서 반복문을 돈다는건 계속 cpu를 사용하고 있다는 뜻)

- 세마포어 (Semaphore) - 대기 큐 : 운영체제 기술로 세마포어 기법을 보완

* S가 음수거나 0일 경우, 바쁜 대기 대신 대기 큐에 넣는다.
* 위쪽 수도코드와 함께 생각

```
// psuedo code
wait(S) { // S가 음수일 경우 루프에 포함되지 않고 큐에 두어 CPU 사용량을 줄인다
    S-> count--;
    if (S->count <= 0) {
        and this process to S->queue;
        block()
    }
}

// wakeup() 함수를 
signal(S) { 
    S->count++;
    if (S-> count <= 1) { // 임계영역에 1개 이상의 프로세스(스레드)가 들어갈 수 있으므로 큐에서 빼서 작업으로 이동
        remove a process P from S->queue;
        wakeup(P)
    }
}

```

- 참고 : 주요 세마포어 함수 (POSIX 세마포어)
* sem_open(): 세마포어를 생성
* sem_wait(): 임계영역 접근 전, 세마포어를 잠그고 세마포어가 잠겨있다면 풀릴 때까지 대기
* sem_post(): 공유자원에 대한 접근이 끝났을 때 세마포어 잠금을 해제한다.

#### 교착상태(Deadlock)와 기아상태(Starvation)

* 교착상태(deadlock) 이란?
    * 무한 대기 상태: 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에, 다음 단계로 진행하지 못하는 상태
        * 배치 처리 시스템에서는 일어나지 않는 문제, 프로세스, 스레드 둘 다 이와같은 상태가 일어날 수 있다.

```
//스레드 A
lock.acquire(a) //locking
// 임계영역
    use a 
    lock.acquire(b) //기다림
    use b
    lock.release(b)
lock.release(a)

//스레드 B
lock.acquire(b)
// 임계영역
    use b
    lock.acquire(a) // 기다림
    use a
    lock.acquire(a)
lock.release(b)

// 수도코드 대로라면 서로 a,b라는 각자의 자원을 기다리면서 교착상태에 빠짐 
```

* 교착상태 발생 조건 : 다음 네 가지 조건이 '모두' 성립될 때, 교착상태 발생 가능성이 있다.
    1. 상호배제(Mutual exclusion): 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
    2. 점유대기(Hold and wait): 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
    3. 비선점(No preemption): 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
    4. 순환대기(Circular wait): 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.

* 교착상태 해결 방법 
    1. 교착상태 예방
        * 4 가지 조건 중 하나를 제거 
            1. 상호배제 조건의 제거: 임계 영역 제거
            2. 점유와 대기 조건의 제거: 한번에 모든 필요 자원 점유 및 해제
            3. 비선점 조건 제거: 선점 가능 기법을 만들어줌
            4. 순환 대기 조건 제거: 자원 유형에 따라 순서를 매김
    2. 교착상태 회피
        * 교착상태 조건 1,2,3은 놔두고 4번만 제거
            * 1,2,3 제거시 프로세스 실행 비효율성이 증대
        * 교착상태 조건 중, 자원 할당 순서를 정의하지 않음(순환 대기 조건 제거)
    3. 교착상태 발견
        * 교착상태가 발생했는지 점검하여 교착 상태에 있는 프로세스와 자원을 발견하는 것
    4. 교착상태 회복
        * 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것

* 기아상태(Starvation)
    * 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태
    * 교착상태와 기아상태
        * 교착상태는 여러 프로세스가 동일 자원 점유를 요청할 때 발생
        * 기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원 할당이 안되는 경우를 주로 의미함

* 기아상태 해결 방안
    * 우선순위 변경
        * 프로세스 우선순위를 수시로 변경해서 각 프로세스가 높은 우선순위를 가질 기회 주기
        * 오래 기다린 프로세스의 우선순위를 높여주기
        * 우선순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청큐 사용
