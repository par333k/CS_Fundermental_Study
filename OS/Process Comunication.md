프로세스 간에는 직접적으로 커뮤니케이션하는 방법은 없다

커뮤니케이션을 위해서는 IPC라는 기법이있다
IPC: InterProcess Communication

왜?

프로세스는 다른 프로세스의 공간을 접근할 수 없다. -- 프로세스 데이터/코드가 바뀔 수 있으니 굉장히 위험하다

그럼에도 프로세스간에 커뮤니케이션이 필요할 때 IPC 기법을 쓴다

필요한 경우?
성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행, 이 때 프로세스간 상태 확인 및 데이터 송수신이 필요
EX) 최근 하드웨어는 CPU의 멀티코어가 많기 때문에 멀티 프로세스로 각 코어에 작업을 할당해 병렬처리로 장비성능을 효율적으로 활용가능
가령 fork() 라는 시스템 콜을 실행하면 프로세스 자신을 복사해서 새로운 프로세스로 만들 수 있다 - 부모/자식 프로세스
1 ~ 10000까지 더할 작업이 있다고 했을때, 10개 프로세스를 통해 1~1000, 1001~2000.. 과 같은 식으로 작업을 할당하여 결과를 합하면 더 빠르게 동작이 가능하다.
이 때, 각 프로세스가 더한 값을 수집해야하므로 프로세스간 통신이 필요한 것이다.
다른 예로, 웹서버의 경우 요청에 대한 각각의 프로세스로 처리할 수 있다면 (CPU 병렬처리가 가능하다면) 요청에 대한 응답이 빨라질 것이다.
그러나 이 경우 각 프로세스의 제어, 상태 정보를 수시로 교환해야만 적절한 대응이 가능하고 이런 경우 프로세스간 통신이 필요한 것이다.


프로세스 메모리는 커널 스페이스와 유저 스페이스로 나뉘어 있다. 커널 영역에는 OS코드가 들어가서 사용자 접근이 기본적으로 되지 않는다.
커널 공간은 운영체제에서 프로세스끼리 공유할 수 있다(실제 물리메모리에서)
메모리 공간도 kernel/user로 구분된다.


프로세스간 통신 방법
(2~7번은 커널 공간을 이용하는 방법이다!)
2,3,4 번은 기본적인 IPC 방법
1. 프로세스의 정보, 결과를 저장공간에 파일로 저장하여 해당 파일을 읽어 내용을 가공한다.
- file을 사용하면, 실시간으로 직접 원하는 프로세스에 데이터 전달이 어렵다. 프로세스가 파일을 읽어야 하는데 파일의 변화를 실시간으로 추적하기가 비효율적이고, 저장매체를 쓰는 경우 I/O 작업 자체가 오래걸리기 때문.

2. Message Queue
- 큐니까, 기본은 FIFO 정책으로 데이터 전송
- 메제지 큐는 부모/자식이 아니라 어느 프로세스간에라도 데이터 송수신이 가능
- 먼저 넣은 데이터가 먼저 읽혀진다 (큐)
## A 프로세스
```
msqid = msgget(key, msgflg) // key는 1234, msgflg는 옵션 - 메세지 큐를 하나 만든다
msgsnd(msqid, &sbuf, buf_length, IPC_NOWAIT) // 메세지 큐에 데이터를 넣는다
```
## B 프로세스
```
msqid = msgget(key, msgflg) // key는 동일하게 1234로 해야 해당 큐의 msgid를 얻을 수 있음
msgrcv(msqid, &rbuf, MSGSZ, 1, 0) // &은 주소라는 뜻, &sbuf의 데이터가 &rbuf로 들어옴. A프로세스에서 B프로세스로 데이터가 전달이 된 셈.
```

3. Shared Memory
- 노골적으로 kernel space에 메모리 공간을 만들고, 해당 공간을 변수처럼 쓰는 방식
- message queue 처럼 FIFO 방식이 아니라, 해당 메모리 주소를 마치 변수처럼 접근하는 방식
- 공유메모리 key를 가지고, 여러 프로세스가 접근 가능
```
//공유 메모리 생성 및 공유 메모리 주소 얻기
shmid = shmget((key_t)1234, SIZE, IPC_CREAT|0666))  // 특정한 함수로 커널공간에 공유메모리 사이즈를 정해 생성
shmaddr = shmat(shmid, (void *)0, 0)    // 주소를 얻고 변수처럼 쓴다

//공유 메모리에 쓰기
strcpy((char *)shmaddr, "Linux Programming")

// 공유 메모리에서 읽기
printf("%s\n", (char *)shmaddr)
```


4. Pipe
- 기본 파이프는 단방향 통신
- fork()로 자식 프로세스를 만들었을 때, 부모와 자식간의 통신
```
char* msg = "Hello Child Process!";
int main() 
{
    char buf[255];
    int fd[2], pid, nbytes;
    if (pipe(fd) < 0) // pipe(fd) 로 파이프 생성
        exit(1);
    pid = fork(); // 이 함수 실행 다음 코드부터 부모/자식 프로세스로 나뉘어짐, pid가 달라지게 됨.
    if (pid> 0) {  // 부모 프로세스는 pid에 실제 프로세스 ID가 들어감
        write(fd[1], msg, MSGSIZE); // fd[1]에 씁니다. MSGSIZE는 msg의 데이터 사이즈
        exit(0);
    }
    else { // 자식 프로세스는 pid가 0이 들어감
        nbytes = read(fd[0], buf, MSGSIZE); // fd[0]으로 읽음 - 자식프로세스에서 fd주소가 달라짐, buf에 msg가 넘어옴 fd[0]으로 부모프로세스의 fd[1]을 읽을수있다
        printf("%d %s\n", nbytes, buf);
        exit(0);
    }
    return 0;
}
```

5. Signal

6. Semaphore

7. Socket