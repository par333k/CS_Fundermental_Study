## 가상메모리
> 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있다

* 예 : 리눅스는 하나의 프로세스가 4GB임
* 통상 메모리는 8기가, 16기가, 32기가 수준
> 폰 노이만 구조는 모든 코드는 메모리에 반드시 있어야 하고, 현대 컴퓨터는 모두 폰노이만 구조를 따른다.

* 멀티프로세스 등을 실행할때 전체 프로세스 메모리를 메모리에 다 올리면 비효율적이고 여러 프로세스 활용이 어렵다
* 이를 해결해 주는 것이 가상 메모리 기술

* 특정 프로세스에서 특정 cpu가 메모리를 사용하는건 한번에 전체를 사용하는 경우는 거의 없다
따라서 메모리 공간을 실제로 사용하는 공간만 주소를 제공한다면 더 효율적이다.
  
### 가상메모리가 필요한 이유
- 하나의 프로세스만 실행 가능한 시스템(배치 처리 시스템 등)
1. 프로그램을 메모리로 로드
2. 프로세스 실행
3. 프로세스 종료 (메모리 해제)
> 필요성이 낮다

- 여러 프로세스 동시 실행 시스템
1. 메모리 용량 부족 이슈
2. 프로세스 메모리 영역간에 침범 이슈
> 필요성이 높다

* 가상메모리 : 메모리가 실제 메모리보다 많아 보이게 하는 기술
    * 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
    * 프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음

* 가상메모리 기본 아이디어 
    * 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소로 바꿔주면 된다
    * virtual address(가상 주소): 프로세스가 참조하는 주소
    * physical address(물리 주소): 실제 메모리 주소

* MMU(Memory Management Unit)
    * CPU에 코드 실행시, 가상주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치.
    
### 가상 메모리와 MMU
* CPU는 가상 메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근
    * 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둠
    CPU -> 가상 메모리 주소 -> MMU -> 물리메모리 주소 -> Memory
      
### 페이징 시스템
* 페이징 개념
    - 크기가 동일한 페이지로, 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
    - 하드웨어 지원이 필요하다
        * 인텔 x86시스템(32bit) 에서는  4KB, 2MB, 1GB 지원
    - 리눅스에서는 4KB로 paging
    - 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용

* 프로세스 (4GB)의 PCB에 Page Table 구조체를 가리키는 주소가 들어 있음
* Page Table에는 가상 주소와 물리 주소간 매핑 정보가 있음

* 페이징 시스템 구조
    * page 또는 page frame: 고정된 크기의 block(4KB)
    * paging system
        * 가상 주소 v = (p, d)
            * p: 가상 메모리 페이지
            * d: p안에서 참조하는 위치 - 변위값, 해당 페이지 번호에 저장된 물리주소로부터 d만큼 떨어진 곳의 물리주소.
    * 페이지 크기가 4KB 예
        * 가상 주소의 0비트에서 11비트가 변위 (d)를 나타내고
        * 12비트 이상이 페이지 번호가 될 수 있음
        * p , d를 통해 실제 메모리 주소 확인이 가능

* 모든 것은 결국 bit와 연결, PCB가 4기가인 이유는 32비트 시스템에서 2의 32승이 4기가이기 때문

### 다중 단계 페이징 시스템
* 32bit 시스템에서 4KB 페이지를 위한 페이징 시스템은
    * 하위 12bit는 오프셋(변위)
    * 상위 20bit가 페이징 번호이므로, 2의 20승(1048576)개의 페이지 정보가 필요함
* 페이징 정보를 단계를 나누어 생성
    * 필요없는 페이지는 생성하지 않으면, 공간 절약 가능

* 페이지 번호를 나타내는 bit를 구분해서, 단계를 나눔(리눅스는 3단계, 최근 4단계)
    * 선형 주소 구조 (10bit - page directory, 10bit - page table, 12bit offset)
    * CR3 레지스터에는 페이지 디렉터리의 시작 주소를 저장(결과적으로 페이지 테이블의 맨 앞이 페이지 디렉터리의 맨앞과 이어짐)
    * 선형 주소의 페이지 디렉토리 내에서 실제 사용하는 페이지 테이블의 시작 주소를 찾음 (페이지 디렉토리는 페이지 테이블의 모음)
    * 해당 페이지 테이블에서 페이지 주소를 찾아서 오프셋 정보화 함께 물리 메모리에서의 주소를 찾음

* MMU와 TLB (컴퓨터 구조)
    * MMU가 물리 주소를 확인하기 위해 메모리를 갖다 와야함
    * 레지스터에서 캐시, 메인 메모리까지 오고가는 엑세스 타임에 있어서 메인 메모리까지 다녀오는 소요 시간은 레지스터와 캐시에 비해 많이 걸림
    * 이를 해결하기 위해 TLB 장비를 개발
    * TLB : Translation Lookaside Buffer 페이지 정보 캐쉬
        - 최근에 변환된 가상주소와 물리주소를 여기에 저상
        - 같은 주소를 다시 찾을경우 MMU 단계에서 바로 TLB를 통해 해당 주소를 가져온다

    * CPU - > 가상 주소 요청 -> MMU -> CR3 을 통해 페이지 테이블 주소 요청 -> 이미 요청한 주소라면 TLB에서 MMU로 주소 전달 ->
    아니라면 메모리에서 MMU로 물리 주소 전달 -> 물리주소를 통해 MMU에서 메모리를 통해 다시 접근 -> 해당 메모리 데이터를 CPU로 전달. 

### 페이징 시스템과 공유 메모리
* 프로세스간 동일한 물리 주소를 가리킬 수 있음 (공간 절약, 메모리 할당 시간 절약)
    * 프로세스가 다른 페이지 테이블을 갖고 있어도 같은 물리 메모리 주소를 참조한다면 공간과 할당 시간이 절약됨
    * 물리 주소 데이터 변경시
        * 물리 주소에 데이터 수정 시도시, 물리 주소를 복사할 수 있음(copy-on-write)
        * 페이지테이블에서 가리키는 페이지 포인터만 변경된 곳으로 바꿔주면 됨
        * 프로세스 생성시간(fork)를 줄일 수 있다
        * 커널, 공유메모리든 공유데이터는 물리 메모리 공간을 공유한다, 공간의 절약

### 요구 페이징 (Demand Paging 또는 Demanded Paging)
* 프로세스 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함
    * 선행 페이징 (prepaging 또는 anicipatory paging)의 반대 개념 : 
    미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념
    * 더 이상 필요하지 않은 페이지 프레임은 다시 저장메체에 저장 (페이지 교체 알고리즘 필요)
