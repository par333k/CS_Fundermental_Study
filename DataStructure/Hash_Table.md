# 해시 테이블
 
* 해시 테이블이란?

    * Key에 데이터(Value)를 저장하는 데이터 구조
    * Key를 통해 바로 데이터를 받아올 수 있으므로 데이터 조회 속도가 빠르다.
    * 배열로 미리 Hash Table 사이즈만큼 생성하는게 일반적
    * Hash는 임의의 값을 고정 길이로 변환하는것을 뜻한다
    * Hash Table은 키 값의 '연산'에 의해 직접 접근이 가능한 데이터 구조이다
    * Hash Table의 값을 찾기 위해 Key에 대한 연산을 하는 것을 Hashing Function이라고 한다.
    이 함수를 통해 key를 연산하여 데이터 위치를 찾는 것이다. (보통 간단히 구현할 때는 나눗셈의 나머지로 많이 구현한다)
    * Hash Value 또는 Hash Address는 Key를 해싱 함수로 연산해, 해쉬 값을 알아내고
    이를 기반으로 해쉬 테이블에서 해당 Key에 대한 데이터 위치를 일관성 있게 찾을 수 있다.
    * Slot은 한 개의 데이터를 저장할 수 있는 공간을 뜻한다.
    * 저장할 데이터에 대해 Key를 추출할 수 있는 별도의 함수도 존재할 수 있다.
    * 데이터에 따라 필요시 key 생성 방법의 정의가 필요할 때가 있다.
    * 일반적인 경우(충돌이 없는 경우)는 탐색/저장/삭제 등 모두 O(1)
    * 최악의 경우(충돌이 모두 발생하는 경우)는 O(n)
        - 일반적인 경우를 기대하고 만드는 것이 해시테이블이기 때문에 O(1)이라고 말할 수 있다
    * 검색에서 해쉬 테이블을 사용 한다면?
        - n개의 배열에 데이터를 저장하고 검색할 때는 O(n)
        - n개의 데이터 저장공간을 가진 해쉬 테이블에 데이터를 저장하고 검색할 때 O(1) 

    ### 장점, 단점, 활용할 때?

    * 장점
        * 데이터 저장/읽기 속도가 빠르다
        * 해쉬는 키에 대한 데이터가 있는지 (중복) 확인이 쉬움

    * 단점
        * 일반적으로 저장공간을 많이 사용한다. (충돌을 피해야함)
        * 여러 키에 해당하는 주소가 동일할 경우 충돌을 해결하기 위한 별도의 자료구조/알고리즘이 필요하다.

    * 주요 용도
        * 검색이 많이 필요한 경우
        * 저장, 삭제, 읽기가 빈번한경우
        * 캐싱 구현
            - 캐싱은 자료를 임시 메모리에 저장하는 과정이다
            - 캐싱의 목표는 해당 자료가 다시 필요할 때 쉽게 자료를 얻는 것
            - 필요한 항목에 대한 히트는 최대화하고 미스는 최소화 해야 한다
            - 컴퓨터에서 데이터 조회는 보통 시간/공간적 지역성을 갖기 때문에 최근에 접근한 메모리 위치와 주변의 위치에서 데이터를 조회할 확률이 높다
            - LFU (Least Frequently Used) 캐싱 : 최소 빈도 사용
                - 운영체제가 메모리 관리하기 위해 사용하는 알고리즘.
                - 블록이 메모리에서 참조된 횟수를 관리
                - linked list, hash table 등을 활용
            - LRU (Least Recently Used) 캐싱 : 가장 오래전 사용
                - 가장 최근에 사용된 노드를 가장 뒤에 위치하게 한다
                - 가장 앞에 있는 노드가 가장 오래전에 사용한 것
                - 헤드 추적이 가능한 linked lis, hash table 주로 사용

    ### 해싱테이블의 충돌 해결 알고리즘 ( 좋은 해쉬 함수 사용하기 )

    * 해쉬 테이블의 가장 큰 문제는 충돌(Collision)의 경우. 이 문제를 충돌(Collision) 또는 해쉬 충돌(Hash Collision)이라고 부른다
    * 해쉬 충돌은 1개 이상의 데이터가 동일한 해시 어드레스에 적용되게 될 경우 생기는 것을 뜻함

        - Chaining 기법
            * 개방 해슁, 또는 오픈 해싱 기법 중 하나: 해쉬 테이블 저장공간 외의 공간을 활용하는 기법
            * 충돌이 일어나면, Linked list 라는 자료 구조를 사용해서, Linked list로 데이터를 추가로 뒤에 연결시켜서 저장하는 기법(배열 형태의 메모리 안에 링크드리스트로 데이터가 이어짐), Tree 로도 구현할 수 있다.

        - Linear Probing 기법
            * 폐쇄 해슁 또는 Close Hashing 기법 중 하나. 해쉬 테이블 저장공간 안에서 충돌 문제를 해결하는 기법.
            * 충돌이 일어나면 해당 hash address의 다음 address부터 맨 처음 나오는 빈공간에 저장하는 기법
                * 저장공간 활용도를 높일 수 있다.
            * 일차 군집화 (특정 해시 값 주변이 가득 차있는 경우)에 그 다음에 이어서 자료를 저장하므로 밀집된 거대한 덩어리가 된다. 이런 단점을 Primary Clustring 이라고 한다.

        - Quadratic Probing 기법 (제곱 탐사법)
            * 선형 탐사법과 원리는 동일하지만 탐사하는 폭이 '제곱'으로 늘어난다는 것이다.     
            * 선형 탐사법에 비해 충돌할 확률은 많이 줄지만 반복될수록 결국 데이터 군집이 생길 수 있고 이것을 Secondary Clustering 이라고 한다.

        - Double Hashing 기법 (이중해싱)
            * 최초 해시를 얻을 때 사용하는 해싱함수와 충돌이 났을 경우 탐사 이동폭을 얻기 위해 사용하는 해싱함수를 함께 준비한다.
            * 충돌 시에는 이동폭을 얻는 해싱함수를 통해 탐사 이동폭을 얻는다.
            * 해당 이동폭으로 탐사하여 빈 버켓에 값을 저장한다
            * 이 경우 최초 해시로 같은 값이 나와도 다른 해시 함수를 거치며 이동폭을 구하기 때문에 골고루 저장될 확률이 비교적 높다.

        - 빈번한 충돌을 개선하는 기법
            * 해쉬 함수를 재 정의하고 해쉬 테이블 저장공간을 늘린다.
        
    * 대표적으로 유명한 해쉬 알고리즘 : SHA, SHA-256 (Secure Hash Algorithm, 안전한 해시 알고리즘)
        * 어떤 데이터도 유일한 고정된 크기의 고정값을 리턴해주므로 해쉬 함수로 유용하게 활용 가능
```
참고
- 모든 자바스크립트 객체는 문자열이나 기호를 키로 받아들이는 간단한 해시맵이라고 볼 수 있다. 
- 자바스크립트 객체는 대표적으로 Object나 Map을 선언해 이용하는데,
  Object는 데이터 적재의 순서를 보장하지 않는 반면, Map은 데이터를 순차적으로 적재한다
- 또한 Map은 모든 값을 key로 활용가능하나 Object는 String이나 Symbol만 가능하다.
- 메모리 크기는 Map의 경우 size 를 이용해 쉽게 파악할 수 있지만 Object는 키를 모두 구해야 알 수 있다.
- Map은 redblacktree로 구현되어 logn의 복잡도를 가지지만 Object는 해시함수를 이용해 key, value를 찾으므로 1의 복잡도를 지닌다.
- 그러나 이 역시 '되도록 충돌하지 않는다'는 점을 전제로 한다. 
```

