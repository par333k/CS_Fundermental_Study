# 트리

* 트리란?
    * 나무를 뒤집어 형태로 데이터구조를 추상화해서 이해하기 때문에 트리라고 부름, HTML 구조가 대표적.
    * Node와 Branch를 이용해서, 사이클을 이루지 않도록 구성한 데이터 구조
    * Node: 트리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함)
    * Root Node: 트리 맨 위에 있는 노드
    * Level: 최상위 노드를 level 0 으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄
    * Parent Node: 어떤 노드의 다음 레벨에 연결된 노드
    * Child Node: 어떤 노드의 상위 레벨에 연결된 노드
    * Leaf Node (Terminal Node): Child Node가 하나도 없는 노드
    * Sibling (Brother Node): 동일한 Parent Node를 가진 노드
    * Depth: 트리에서 Node가 가질 수 있는 최대 Level
    * Node가 N개인 트리는 항상 N-1개의 간선(branch)를 가진다
    * 루트에서 어떤 노드로 가는 경로는 유일하다
    * 순환을 갖지 않는 '연결 그래프'로서 계층형 데이터 구조이다.
        * 선형 데이터 구조는 원소들이 순차적으로 나열된 구조로 리스트, 스택, 큐 같은 것들이다.

```
* 참고
- 트리는 왜 순회해야 하나?
트리는 선형구조가 아니다. 따라서 '모든 노드들을 거쳐가기 위한 효율적인 방법'이 꼭 필요하다. 그렇다보니 순회를 위한 알고리즘을 같이 생각해야하고 대표적으로  깊이우선탐색(DFS)와 너비우선탐색(BFS)가 있다.
```

# 이진 트리 (Binary Tree)

* 이진트리란?
    * 이진트리는 각 노드가 하나, 혹은 두개의 자식 노드만을 가지고 있는 상태의 트리구조이다.
        - 완전 이진 트리 : 자식노드가 없는 leaf 노드를 제외한 모든 노드가 2개의 노드를 가지고 있으며 트리의 맨 마지막 level의 모든 노드가 값이 채워져 있는 트리. 
            - 완전 이진트리는 각 level에서 내려갈수록 노드는 정확하게 2배의 개수가 된다
            - 마지막 level의 모든 노드 수의 총합은 그 이전 level 까지의 모든 노드의 수의 총합 +1이다. 바꿔 말하면 마지막 level에 전체 노드의 절반이 있다는 의미.
        - Full Binary Tree : 각 노드의 자식 노드가 0개거나 2개만 있는 경우
    
    * 이진 트리의 표현
        - 1차원 배열: 이진 트리의 i 번째 노드를 배열의 i번째 요소에 저장하여 표현
            - 장점: 노드의 위치를 인덱스에 의해 쉽게 접근 가능
            - 단점: 특정 트리에서 메모리 공간 낭비가 심할 수 있다
        - linked list: 자식을 가리키는 포인터 필드를 포함하는 노드로 표현
            - 장점: 메모리 공간을 절약할 수 있고 삽입/삭제가 용이
            - 단점: 이진 트리가 아닌 일반 트리의 경우 노드의 차수만큼 가변적인 포인터 필드가 필요해서 접근하기 어렵다.     

    * 이진 트리의 시간 복잡도
        * 탐색시 시간 복잡도는 depth(트리의 높이)를 h로 표현할 때 O(h)
        * n개의 노드를 가진다면, h = log2n에 가까우므로, 결과적으로 시간 복잡도는 O(logn)
            * O(logn)인 이유 : 한 번 실행시마다 50%의 실행할 수도 있는 명령을 제거하여 실행시간을 절반씩 단축할 수 있기 때문 (Divide And Conquer의 개념으로 대/소 비교나 알파벳 순서 비교등 기준에 따라반을 자르고 나머지를 확인하는 개념)

    ### 이진 탐색 트리     

    * 이진 탐색 트리의 경우 현재 노드의 오른쪽 자식 노드는 반드시 현재 노드보다 큰 값을, 왼쪽에 있는 노드는 작은 값을 가진다. 이진 트리기 때문에 당연히 각 노드는 최대 2개까지의 노드만 가진다. 
    * 이진 탐색 트리는 탐색시 이진트리의 장점 그대로 굉장히 빠르다. 그러나 노드의 level이 매우 깊을 때의 삭제/추가와 같은 작업은 해시테이블보다 비효율 적일 수도 있다(해시테이블의 O(1))
    * 균형이 잡히지 않은 치우친 이진 탐색 트리는 모든 요소를 iterating 하는 배열과 다를바가 없어 O(n)의 시간복잡도를 지닌다. 그래서 이진 탐색 트리는 균형을 잡는게 중요하다.         

    * 이진 탐색 트리의 삭제는 매우 복잡하다
        * 삭제할 노드가 없는 경우를 먼저 탐색
        * 삭제할 노드가 leaf node(branch 가 없을때) 일때
            - 삭제할 노드의 Parent Node가 삭제할 Node를 가리키지 않도록 한다. 
        * 삭제할 노드의 child node가 1개 일때 (branch 1개)
            - 삭제할 Node의 Parent Node가 삭제할 Node의 Child Node를 가리키도록 한다.
        * 삭제할 노드의 child node가 2개 일때 (branch 2개, 삭제할 Node가 Parent Node 왼쪽에 있을 때)
            - 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키도록 한다.
                - 1. 삭제할 Node 가 Parent Node의 왼쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 Child Node가 없을 때
                - 2. 삭제할 Node가 Parent Node의 왼쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 오른쪽에 ChildNode가 있을때
                    - 가장 작은 값을 가진 Node의 Child Node가 왼쪽에 있는 경우는 없음. 왜냐하면 왼쪽 Node가 있다는 것은 해당 Node보다 더 작은 값을 가진
                    Node가 있다는 뜻이기 때문이다
            - 삭제할 Node의 왼쪽 자식 중, 가장 큰 값을 삭제할 Node의 Parent Node가 가리키도록 한다.   
        * 삭제할 노드의 Child Node가 2개 일 때 (branch 2개, 삭제할 Node가 Parent Node 오른쪽에 있을 때)
            - 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키도록 한다.
                - 1. 삭제할 Node 가 Parent Node의 왼쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 Child Node가 없을 때
                - 2. 삭제할 Node가 Parent Node의 왼쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 오른쪽에 ChildNode가 있을때
                    - 가장 작은 값을 가진 Node의 Child Node가 왼쪽에 있는 경우는 없음. 왜냐하면 왼쪽 Node가 있다는 것은 해당 Node보다 더 작은 값을 가진
                    Node가 있다는 뜻이기 때문이다
            - 삭제할 Node의 왼쪽 자식 중, 가장 큰 값을 삭제할 Node의 Parent Node가 가리키도록 한다.  
        * 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키게 할 경우
            - 삭제할 Node의 오른쪽 자식 선택
            - 오른쪽 자식의 가장 왼쪽에 있는 Node를 선택
            - 해당 Node를 삭제할 Node의 Parent Node의 왼쪽 Branch가 가리키게 함
            - 해당 Node의 왼쪽 Branch가 삭제할 Node의 왼쪽 Child Node를 가리키게 함
            - 해당 Node의 오른쪽 Branch가 삭제할 Node의 오른쪽 Child Node를 가리키게 함
            - 만약 해당 Node가 오른쪽 Child Node를 가지고 있었을 경우에는, 해당 Node의 본래 Parent Node의 왼쪽 Branch가 해당 오른쪽 Child Node를 가리키게 함

    ### 이진 트리의 장단점, 활용
    
    * 장점
        * 탐색에서의 성능이 빠르다. 배열은 O(n)이지만 이진트리는 적절한 경우 O(logn) 이다.

    * 단점
        * 평균 시간 복잡도는 O(logn) 이지만, 이는 트리가 균형잡혀 있을 때의 평균 시간복잡도
        * 따라서 최악의 경우, 한쪽으로 기울어진 이진트리는 Linked list와 동일한 시간복잡도인 O(n)
            * 그렇기 때문에 균형을 맞추기 위한 B-tree, AVL tree, redblacktree 등으로 이진트리 알고리즘이 발달.

    * 활용
        * 폴더구조, 계층구조 등을 표현하는 자료에 사용
        * 탐색이 빠르기 때문에 검색엔진, DBMS에도 사용
# B-Trees

* 자식을 두개만 가질 수 있는 이진 트리를 확장하여 더 많은 자식을 가질 수 있으며 자동으로 균형을 맞춘다.

# AVL Trees

* LR회전, RR회전, RL 회전 등을 통해서 자동으로 트리의 균형을 맞춘다

# Red Black Trees

* 이진 트리에 색상이라는 속성을 노드에 추가하여 자동으로 균형을 맞춘다.

``` 
참고
- 이진 탐색 트리가 log2n의 시간복잡도를 가지는 이유는 자식이 두 개라는 본질적인 원칙이 있기 때문이다. 그렇다면 3개일때는 log3n이 되면서 더 속도가 빨라지는 거 아닌가?
- 그렇지 않다. 실제 이진트리를 구현할때에는 조건문이 1개면 충분하다. 
그러나 자식노드가 늘어날수록 조건문의 숫자 역시 늘어나야 한다
따라서 실제 걸리는 상수를 포함한 시간 복잡도는 2nlog3n과 nlog2n의 비교라고 볼 수 있다. 그렇기 때문에 실제로 자식이 늘어나면 성능은 오히려 낮아진다.
```
