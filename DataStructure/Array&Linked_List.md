# 배열

* Array 개념
    * 데이터를 나열하고, 각 데이터를 인덱스에 대응하도록 구성한 데이터 구조
    * 논리적 저장 순서와 물리적 저장 순서가 일치하므로 인덱스로 원소에 접근 가능하다.
    * 인덱스를 안다는 가정하에, O(1) 시간복잡도로 해당 원소에 접근이 가능하다. ramdom access가 가능하다.
    * 배열의 삭제, 또는 삽입의 경우 '연속적인' 특징이 깨진다.(빈 공간이 생긴다)
    * 이 경우 시간 복잡도는 O(n)이 된다. (인덱스/원소들을 shift 해줘야 하는 경우가 생기기 때문)

## 장점 및 단점, 활용할 때?

* 장점
    * 구현이 쉽다. 대체로 고급 언어에는 기본적으로 내장객체화 되어 있다.
    * 인덱스를 활용한 무작위 접근이 가능해 시간복잡도가 낮다.
    * 순차접근의 경우에도 배열은 데이터를 하나의 연속된 메모리공간에 할당하므로 Linked list 보다 빠른 성능을 보여준다.
    * 참조를 위한 추가적인 메모리 할당이 필요 없다.

* 단점
    * 원소의 삽입/삭제에 비효율적이다.
    * 배열 생성시 지정한 크기를 기본적으로 바꿀 수 없다. 리사이징을 해야할 경우 추가적으로 할당하는 메모리 역시 순차성을 지켜야 하므로 성능부하가 생긴다.
    * 메모리 재사용이 불가능하다. 원소값이 없어도 배열 크기만큼의 메모리를 미리 선점한다

* 언제 사용할까?
    * 순차열적인 데이터 목록을 저장할 때 
    * 다차원 데이터를 다룰 때(다차원 배열)
    * 특정 요소를 빠르게 읽어야 할 때
    * 데이터 목록의 사이즈가 변동이 적을때
    * 요소가 자주 삭제/추가 되지 않을 때

# Linked List

* Linked List 개념
    * 각각의 원소들은 자기 다음에 어떤 원소가 있는 지에 대한 위치만을 기억한다
    * 보통 처음 노드를 haed, 마지막 노드를 tail 이라고 한다. 
    * 서로 이전과 다음 단계처럼 연결되어 있는 자료구조
    * 삽입/삭제는 O(1)의 복잡도를 지닌다. 위치만 알면 다음에 바라볼 노드의 위치만 바꿔주면 되기 때문이다.
    * 그러나 노드의 위치를 알기 위해 찾는 조회과정은 O(n)의 복잡도를 지닌다. 일일히 어디에 있는지 찾아야 하기 때문인데 이는 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문이다
    * 따라서 실제로는 어느 위치에 원하는 원소가 있는지 명시적으로 알지 못하는 상태에서는 삽입/삭제/조회 모두 O(n)의 복잡도를 지니는 것이 된다.
    * Linked List는 Tree구조의 근간이 되며 Tree에서 그 유용성이 드러난다.
    * 단순 연결 리스트, 이중 연결 리스트, 원형 연결 리스트, 청크 리스트 등의 구현법이 있다.
        #### 단순 연결 리스트
        * 다음 노드에 대한 참조만을 가진 가장 단순한 형태의 연결 리스트. 가장 기본적인 형태이다. 보통 큐를 구현할때 쓴다. 다음 노드를 참조하는 주소를 잃을 경우 데이터 전체를 못 쓰게 된다는 단점이 있어 안정적이지 않다. FAT 파일 시스템이 단순 연결리스트로 파일 청크를 연결한다.

        #### 이중 연결 리스트
        * 다음 노드의 참조 및 이전 노드의 참조도 같이 가리키게 한다. 현재 노드의 앞 뒤 원소의 위치를 전부 아는 것. 이를 통해 이중 연결 리스트는 삭제하는 부분에 장점이 있는데, 대신 관리해야할 참조가 두개나 있어 삽입/정렬은 더 까다롭고 자료구조의 크기도 좀 더 커진다.
        * 단일 연결 리스트에 비해 이전/다음 참조 중 하나가 끊어져도 순회가 가능하여 데이터 체인을 복구할 수 있다. 다만 이런 보정 알고리즘은 따로 구현을 해야하고, 그렇지 않다면 이전/다음 참조 중 하나는 갱신을 하고 하나는 갱신하지 않을 경우 한쪽으로 순회시 도달 불가능한 잃어버린 노드가 발생한다.

        #### 원형 연결 리스트
        * 단순 연결 리스트에서 마지막 원소가 null 대신 처음 원소를 가리키게 하면 순회가 되며 원형 리스트라고 표현한다. 이중 연결 리스트 역시 처음과 끝을 서로 이으면 이중 원형 연결 리스트라고 표현한다. 스트림 버퍼의 구현에 많이 사용하며, 이미 할당된 메모리 공간을 삭제하고 재할당 하는 부담이 없기 때문에 큐를 구현하는 데에도 적합하다

        #### 청크 리스트
        * 배열과 리스트의 장점을 합친 것으로, 리스트의 멤버가 배열이다. CPU에 캐시 기능이 있는 경우 지역성Locality이 떨어지는 연결 리스트는 심각한 성능 저하를 불러온다. 이를 보완하기 위해 리스트의 멤버를 레코드의 배열로 하는 것이고, 이것의 발전형이 바로 B+tree 이다.

## 장점 및 단점, 활용할 때?

* 장점
    * 배열과는 단리 자료의 삽입/삭제가 용이하다
    * 리스트 내에서 자료의 이동이 필요하지 않다
    * 동적으로 메모리를 할당하기 때문에 메모리 재사용이 가능하다
    * 원소가 없어도 메모리를 미리 선점할 필요가 없다.

* 단점
    * 다음 원소의 위치를 메모리에 저장하기 때문에 포인터 등의 메모리 공간이 필요하다
    * 구현과 활용이 까다롭다(알고리즘이 배열에 비해 복잡하다)
    * 특정 자료의 탐색 시간이 배열보다 많이 걸린다(인덱스가 없기 때문)

* 언제 사용할까?
    * 다음, 이전, 순회 등의 데이터를 다루고 삽입/삭제가 자주 일어날 때
    * 음악 선호 목록 리스트 같은 경우
    * 여러 목록에 대한 메모리를 유연하게 사용해야 할때(동적으로 활용)
