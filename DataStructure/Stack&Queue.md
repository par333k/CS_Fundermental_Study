# Stack

* Stack 이란?
    * 선형적 자료구조이며 LIFO(Last in First Out) 규칙을 지닌다. 
    * 즉, 자료에 대한 접근이 뒤에서부터만 가능하다.
    * 보통 배열이나 링크드 리스트를 이용해 구현할 수 있다
    * 데이터를 삽입하는 push, 삭제하는 pop, 데이터를 확인하는 peek 와 같은 메소드가 있다.
    * 스택으로 할당받은 메모리 부분의 마지막 주소에 대해 Top Pointer의 값이 마지막 주소 값보다 커지면 스택의 모든 기억장소가 꽉 채워져 있는 것으로 자료를 더 이상 삽입할 수 없어 Overflow를 발생시킨다.
    * Top Pointer가 주소 0을 가지고 있다면 스택에는 자료가 없으므로 삭제하려고 시도하면 Underflow를 발생시킨다.
    * 즉, 스택에 저장한 자료에 대해 자료를 삭제시킬때는 자료가 있는지 없는지를 확인해야한다
    * 스택은 힙 영역 메모리에서 일반적인 데이터를 저장하는 스택과 스택 영역 메모리에서 프로그램의 각 분기점에 변수와 같은 정보를 저장하기 위한 스택이라는 두 가지 의미로 사용될 수 있므로 유의해야 한다.

    ## 장점 및 단점, 활용할 때?
    
    * 장점
        * 개념적으로 이해하기 편리하다
        * 참조지역성 '한번 참조된 곳은 또 참조될 확률이 굉장히 높다'는 개념이 있다. 그 원리 중 시간지역성의 원리라는 것이 있는데 시간지역성은 최근에 참조된 자료가 다시 참조될 확률이 높다는 것이다. 스택은 마지막에 넣은 자료를 제일 먼저 뺀다는 점에서 시간지역성을 최고로 활용할 수 있다.
        * 원소를 삽입/삭제하는 경우 O(1)의 복잡도를 지닌다

    * 단점 
        * 데이터 갯수는 알 수 있어도 탐색은 원소를 다 꺼내가면서 파악해야한다.

    * 언제 사용할까?
        * 프로그램 호출 시 복귀 주소를 저장할 때
        * 함수의 호출 순서를 제어할 때
        * 인터럽트 발생 시 복귀 주소를 저장핼 때
        * 재귀 프로그램의 순서를 제어할 때
            * 재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어준다.
            * 재귀함수를 빠져 나와 퇴각 검색(backtrack)을 할 때는 스택에 넣어 두었던 임시 데이터를 빼 줘야 한다.
            * 스택은 이런 일련의 행위를 직관적으로 가능하게 해 준다.
            * 또한 스택은 재귀 알고리즘을 반복적 형태(iterative)를 통해서 구현할 수 있게 해준다
        * 웹 브라우저 방문기록
        * 역순 문자열 만들기
        * 후위 표기법 계산
        * 실행 취소 


        
```
스택을 구현하는 대표적인 방법은 배열과 연결리스트다. 두 가지 자료구조를 가지고 스택을 구현할때의 핵심적인 특징은 '스택의 크기'이다

고정적으로 메모리를 확보하고 최대크기가 너무 크지 않을 때는 배열이, 그렇지 않을 때는 연결리스트가 효율적일 수 있다. 
다만 연결리스트로 구현하는 것이 개발은 더 까다롭다. 
특히 연결리스트는 구현시 링크에 대한 메모리 필드가 필요하므로 메모리를 좀 더 사용하게 된다.

연결리스트의 단점 중 하나는 탐색에 불리하다는 것이었다. 그러나 스택은 탐색의 원칙이 이미 정해져있다. 
바로 LIFO다. 그래서 스택은 연결리스트의 단점을 상쇄하는 형태이기도 하다.
```

# Queue

* 큐란?
    * 스택과는 다르게 FIFO(First in First Out)을 따른다
    * enqueue, dequeue 등으로 큐에 자료를 넣거나 빼는걸 구현한다.
    * 큐는 주로 배열, 연결리스트로 구현하는 경우가 많다.
    * 큐는 스택과 마찬가지로 Underflow, Overflow가 존재한다
    * 선형 큐의 경우 배열을 통해 일직선으로 구현하는데, 이 때는 배열의 약점이 그대로 드러난다. 가령 큐에 데이터가 꽉 차면 데이터를 더 추가하는데 상당한 연산이 필요하다.
    또한 배열의 특성상 맨 앞의 데이터를 dequeue 하더라도 고정된 메모리를 갖고있기 때문에 메모리 낭비가 커진다. 이걸 수정하기 위해 다음 모든 원소들을 앞으로 당기면 성능 낭비로 비효율적인 자료구조가 될 수 있다.
    * 원형 큐(링 버퍼)의 경우 선형 큐의 단점을 해소하기 위해 나온 형태다. 배열로 구현할 경우 배열의 마지막 인덱스에서 다음 인덱스로 넘어갈 때 '(index+1)%배열의사이즈'를 이용하여 에러를 일으키지 않고 인덱스 0으로 순환되는 구조로 만들 수 있다.
    * 원형 큐를 배열로 구현할 경우 0번 인덱스를 비워두게 된다고 가정한다. 정확히는 front가 가르키는 곳이라고 생각하면 front가 위치한 곳은 항상 데이터가 들어올 수 없다고 가정하는 것이다. 큐가 가득찼다는걸 알기 위해서 front == (rear+1)%queuesize를 이용하기 때문이다.
    * 데이터가 1번인덱스부터 들어가면 rear도 함께 바라보는 대상이 데이터가 들어올때마다 바뀐다. 마지막 데이터를 가리키는게 rear기 때문. 즉, 다음 데이터는 항상 rear의 다음에 저장된다
    * 배열의 마지막 칸까지 데이터가 가득차서 마지막 인덱스 위치가 rear일 경우 큐가 가득차서 데이터를 넣을 수 없다.
    * 이 때, 인덱스 1번의 데이터를 비우게 되면 인덱스 1은 front가 되고, 메모리 공간이 하나 확보되며(인덱스 0) 여기에 데이터를 추가로 넣을 수 있다. 그러면 배열의 원소 순서를 변경하지 않고도 큐를 유지할 수 있다. 직관적으로 보자면, front는 데이터를 삭제할때 1칸 움직이고, rear 는 데이터를 추가할 때 1칸 움직인다.

    ## 장점 및 단점, 활용할 때?

    * 장점
        * 직관적으로 사용하기 좋다
        * 복잡도는 스택처럼 삽입/삭제의 경우가 이미 정해져 있으므로 O(1)의 시간복잡도를 지닌다.

    * 단점
        * 배열로 이뤄진 선형 큐의 경우 메모리 문제가 있다.
        * 선형 큐가 아닌 원형 큐, 우선순위 큐 등을 사용할 때에는 구현 난이도가 올라간다.

    * 언제 사용할까?
        * 데이터가 입력된 시간 순으로 처리해야 할 필요가 있는 상황에 이용하기 좋다
        * 너비우선탐색(BFS) 구현
            * 처리해야 할 노드의 리스트를 저장하는 용도로 Queue를 사용
            * 노드를 하나 처리할 때마다 해당 노드와 인접한 노드들은 큐에 다시 저장
            * 노드를 접근한 순서대로 처리할 수 있다.
        * 캐시(Cache) 구현
        * 우선순위가 같은 작업 예약 (인쇄 대기열)
        * 선입선출이 필요한 대기열 (유통기한, 티켓카운터)
        * 콜센터 고객 대기시간
        * 프로세스 관리
        * CPU 관리 방법 
            * FCFS/FIFO 스케쥴링 기법: 프로그램이 준비 큐에 도착한 순서대로 CPU를 할당받는다
            * Round Robin 스케쥴링 기법: 대화형 시스템에 사용되는 스케쥴링 방식이다. 도착한 순서대로 CPU가 할당되지만 CPU의 시간 할당량 또는 시간 간격에 의해 제한을 받는다. 질정한 크기의 시간 할당량을 모든 작업에 주고 그 시간동안 작업이 완료되지 못하면 준비 큐의 맨 뒤에 다시 배치한다.

#### 우선순위 큐(Priority Queue)

* 우선순위 큐란?
    * 우선순위 큐는 비 선형적 자료구조의 형태이다. FIFO가 아니라, 들어가는 순서에 관계없이 우선순위에 맞춰서 데이터가 dequeue된다.
    * 우선순위 큐도 큐이기 때문에 배열/ 연결리스트로 구현가능하고 단점 역시 동일하다(오버해드)
    * 그래서 우선순위 큐는 Heap을 이용해 구현하기도 한다.
    * 힙 기반 우선순위 큐의 데이터 삽입/삭제 시간 복잡도는 O(log2n) 이다.
    * 우선순위 큐는 사실 가장 일반적인 자료구조라고 생각할 수도 있는데, 가령 FIFO라는 원칙을 개발자가 적용하면 큐가 되는 셈이고, LIFO 기준을 우선순위로 적용하면 스택이 되기도 한다. 
    * 배열로 구현할 경우 우선순위가 중간인 것이 삽입될 때 복잡도는 O(n)이 된다
    * 연결리스트로 구현할 경우 최악의 경우 삽입위치가 맨 끝이라면 역시 O(n)이 된다.
    * 그러나 힙 기반으로 구현하면 삭제/삽입과정에서 모두 부모-자식간의 비교만 계속 이뤄지므로 O(log2n)이 된다. (이진 트리의 높이가 하나 증가할 때마다 저장 가능한 자료의 갯수는 2배로 늘며 비교 연산 횟수는 1회 증가하기 때문)
    * 힙은 완전이진트리로 구성된 자료구조이다.
    * 힙에서 모든 노드에 저장된 값(우선순위큐 에서는 우선순위)들은 자식 노드들의 것보다 우선순위가 크거나 같다.
    * 따라서 힙은 루트 노드에 우선순위가 높은 데이터를 위치시키는 자료구조이다. 
    * 가령 최대 힙은 완전 이진트리이면서 루트 노드로 올라갈 수록 저장된 값이 커지는데, 이 때 우선순위는 값이 큰 순서대로 매긴다.
    * 최소 힙은 완전 이진트리이면서 루트 노드로 올라갈수록 값이 작아지는 구조로 우선순위는 값이 작은 순서대로 매긴다.
    
    
